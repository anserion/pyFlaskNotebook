# Copyright 2021 XXXXXX XX XXXXXXXX (XXXXXXXX @ XXXXX.XXX)
# имя автора скрыто по условиям задания
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ------------------------------------------------------

# pyFlaskNotebook - простая электронная WEB-записная книжка
# третье проектное задание Яндекс.Лицей "второй год"
# ------------------------------------------------------
# имитируется работа простой электронной записной книжки,
# основанной на использовании библиотеки WEB-программирования Flask,
# базы данных SQLite3 и ООП-оболочки SQLAlchemy поверх базы данных.

# Для запуска программы выполнить в командной строке
# рабочего каталога программы:
#   (skiped)@linux_box: python3 pyFlaskNotebook.py
# серверная часть программы по-умолчанию контролирует 8080 порт
# (номер порта меняется или в коде или в конфигурационном файле config.py
# по умолчанию номер порта "зашит" в код, для переключения на конфигурационнй
# файл можно закомментировать (необязательно) строки в коде и раскомментировать
# загрузку конфига) -- строка 187

# Файл базы данных с именем pyNotebook.db имеет формат SQLite3 и должен
# располагаться в рабочем каталоге программы. Если этого файла
# программа не обнаружит, то автоматически после первого запроса
# к базе будет создан новый файл базы данных pyNotebook.db 

# для доступа к серверу:
# 1) запустить браузер интернета, поддерживающий HTML5
#    (тестировалось на Firefox 85.0 (64-бит) OS Linux Mint 2020.1)
# 2) в адресной строке браузера ввести http://127.0.0.1:8080 или
#    сокращенный вариант 127.0.0.1:8080
# (ВНИМАНИЕ! поддержка https-протокола "из коробки" специально не делалась)
# ------------------------------------------------------

# ------------------------------------------------------
# если что-то "пошло не так"
# ------------------------------------------------------
# 1) установить Linux (тестировалось на Linux Mint 2020.1)
# 2) для установки python3 выполнить:
#    (skiped)@linux_box: sudo apt install python3
# 3) для установки библиотеки flask выполнить:
#    (skiped)@linux_box: sudo python3 -m pip install flask
# 4) для установки библиотеки sqlalchemy выполнить:
#    (skiped)@linux_box: sudo python3 -m pip install sqlalchemy
# 5) для установки библиотеки flask-wtf выполнить:
#    (skiped)@linux_box: sudo python3 -m pip install flask-wtf
# 6) для установки библиотеки flask-login выполнить:
#    (skiped)@linux_box: sudo python3 -m pip install flask-login

# Дополнительные зависимости (jinja2, itsdangerous, werkzeug, greenlet, WTForms
# и т.п.) должны "подтянуться" автоматически
# ------------------------------------------------------

# ------------------------------------------------------
# Что собственно программа делает
# ------------------------------------------------------
# Имитируется работа простой электронной записной книжки c доступом из
# браузера интернета (WEB-интерфейсом)
# После подсоединения к сереврной части (ввести 127.0.0.1:8080 в адресной
# строке браузера) отрисовывается страница парольного входа в систему
# 127.0.0.1/login, в которой нужно ввести имя пользователя системы
# (yandex) и его пароль (123456)
# Правильные имя и пароль "зашиты" в коде программы (сделано специально для
# методических целей), однако эти строки можно закомментировать (необязательно)и
# раскомментировать строки для загрузки настроек (в том числе для входа
# из конфигурационного файла config.py). -- строки 175,176
# Окно входа в систему будет перересовываться до тех пор, пока пользователь
# не введет правильные имя пользователя и пароль (из методических соображений
# модные технологии типа Kerberos, OpenID и т.п. в программе не реализовывались)
# После успешного входа пользователь переадресуется на главную страницу
# 127.0.0.1/index (попасть на эту страницу без авторизации "напрямую"
# не получится (будет проходить переадресация на 127.0.0.1/login))
# Страница 127.0.0.1/index содержит приветствие и предложение ввести дату
# для поиска или коррекции данных в записной книжке (по умолчанию выставлена
# дата "сегодня" и отрисованы данные из базы данных на "сегодня").
# Дата выбирается ГПИ-виджетом DateField (обычный календарь, но он 
# требует поддержки HTML5 браузером) и после этого нажимается кнопка
# "Дату подтверждаю". Если нажать кнопку "Дату подтверждаю" без выбора даты,
# то будет установлена дата "сегодня" (при нажатии сразу после входа в систему)
# или последняя выбранная дата (если с системой в текщей сессии
# уже "немного поработали").
# После нажатия кнопки "Дату подтверждаю" из базы данных извлекается
# текстовая информация-запись и отображается в поле "Запись в книжке на дату"
# Ознакомившись с записью, ее можно откорректировать и заменить, соответственно
# откорректировав и нажав кнопку "Заменить запись" или удалить из базы данных,
# нажав кнопку "Удалить запись" (в этом случае запись удалится из базы данных,
# в окне "Запись в книжке на дату" появится "на дату ... записей в книжке нет")
# Из системы можно "разлогиниться", перейдя по гиперссылке "Выход из системы"
# (127.0.0.1/logout).
# Можно повторно войти в систему по гиперссылке "Вход в систему", если вдруг
# WEB-приложение "забыло" пользователя.
# Ответная реакция системы (доступ разрешен, неправильные имя пользователя или
# пароль, запись удалена, запись модифицирована и т.п.) отображается при
# помощи flash-сообщений в нижней части страниц WEB-приложения.

# Краткий алгоритм работы с компьютерной программой (WEB-приложением):
# 1) Запустить серверную часть: python3 pyFlaskNotebook.py
# 2) Запустить WEB-браузер, например Firefox 85.0 (64-бит)
# 3) В адресной строке браузера ввести 127.0.0.1:8080
# 4) В появившемся окне входа в систему ввести имя пользователя и его пароль
#    (по-умолчанию yandex/123456) или сразу к шагу 5 (если вход сохранился)
# 5) Выбрать дату записи в записной книжке и нажать кнопку "Дату подтверждаю"
# 6) Просмотреть запись, при необходимости ее откорректировать
# 7) При необходимости нажать кнопку "Заменитьзапись " или "Удалить запись"
# 8) При необходимости повторите шаги 5-7
# 9) Для корректного завершения сессии перейдите по гиперссылке
#    "Выход из системы" в верней части страницы
# 10) Для окончательного выхода из WEB-приложения закройте браузер
#     (рекомендуется перед закрытием осуществить шаг 9)
# ------------------------------------------------------

# ------------------------------------------------------
# подключаемые модули
# ------------------------------------------------------
# Общесисистемные python-модули
import os
import datetime
from datetime import datetime

# Модули библиотеки Flask
from flask import Flask
from flask import render_template
from flask import request
from flask import redirect
from flask import flash
from flask import session
from flask import url_for
from flask import g

# Модули библиотеки Flask-login
from flask_login import LoginManager
from flask_login import login_user
from flask_login import logout_user
from flask_login import current_user
from flask_login import login_required

# Модули библиотеки Flask-wtf
from flask_wtf import Form
from wtforms import TextField
from wtforms import TextAreaField
from wtforms import PasswordField
from wtforms import BooleanField
from wtforms import SubmitField
from wtforms import DateField
from wtforms.validators import Required
from wtforms.validators import Length

# Модули библиотеки SQLAlchemy
import sqlalchemy
import sqlalchemy.orm
from sqlalchemy.ext.declarative import declarative_base
# ------------------------------------------------------
# Конец блока импорта модулей
# ------------------------------------------------------

# ------------------------------------------------------
# Имя пользователя и его пароль для входа в систему
# ------------------------------------------------------
good_name = 'yandex'     # предустановленное имя пользователя
good_password = '123456' # предустановленный пароль
# ------------------------------------------------------
# Раскомментируйте 2 строки ниже, если нужна загрузка парольной информации
# из файла config.py
#from config import good_name
#from config import good_password
# ------------------------------------------------------

# ------------------------------------------------------
# Инициализация Flask-подсистемы
# ------------------------------------------------------
# номер порта, прослушиваемого системой Flask
flask_port=8080 # предустановленный номер порта
# ------------------------------------------------------
# Раскомментируйте строку ниже, если нужна загрузка номера порта
# из файла config.py
#from config import flask_port
# ------------------------------------------------------

# создаем глообальный объект flask-приложения
app = Flask(__name__)
# настраиваем его
app.config.update(CSRF_ENABLED=True, SECRET_KEY='123456') # защита форм
# ------------------------------------------------------
# Раскомментируйте строку ниже, если нужны другие ключи защиты форм
# из файла config.py
#app.config.from_object('config')
# ------------------------------------------------------
# конец инициализации Flask-подсистемы
# ------------------------------------------------------

# ------------------------------------------------------
# Инициализация Flask-login-подсистемы
# ------------------------------------------------------
# создаем объект-экземпляр контроля пользователей системы
lm = LoginManager()
# указываем с какой из Flask-подсистем (а вдруг их несколько :) ) работать
lm.init_app(app)
# страница входа в систему
lm.login_view = 'login'

# ------------------------------------------------------
# класс пользователя, необходим для корректной работы модуля flask-login
# ------------------------------------------------------
class User():
    name = 'yandex'

    def is_authenticated(self):
        return True
    
    def is_active(self):
        return True
    
    def is_anonymous(self):
        return False

    def get_id(self):
        return str(self.name)
# создаем экземпляр класса User (необходим подпрограмме load_user)
user = User()
# ------------------------------------------------------
# конец описания класса User
# ------------------------------------------------------

# ------------------------------------------------------
# подпрограмма активации пользователя в структурах модуля flask-login
# ------------------------------------------------------
@lm.user_loader
def load_user(id):
    # возвращаем пользователя-экземпляра класса User
    return user
# ------------------------------------------------------
# конец подпрограммы load_user
# ------------------------------------------------------
# конец инициализации Flask-login-подсистемы
# ------------------------------------------------------

# ------------------------------------------------------
# Инициализация SQLAlchemy-подсистемы
# ------------------------------------------------------
# рабочий каталог программы
basedir = os.path.abspath(os.path.dirname(__file__))
# URI-путь к файлу базы данных
SQLALCHEMY_DATABASE_URI = 'sqlite:///' + os.path.join(basedir, 'pyNotebook.db')

# инициализация движка базы данных
SqlAlchemy_engine = sqlalchemy.create_engine(SQLALCHEMY_DATABASE_URI, echo=False)
# выбираем упрощенную схему иницализации структур SQLAlchemy
SqlAlchemy_Base = declarative_base()
# создаем конструктор (фабрику) сессий базы данных
sql_session_factory = sqlalchemy.orm.sessionmaker(bind=SqlAlchemy_engine)
# создаем главную сессию базы данных
sql_session = sql_session_factory()
# тут, по-хорошему, нужно сделать кучу проверок, но с методической точки зрения
# код сильно загромоздится

# ------------------------------------------------------
# ООП-описание таблицы nb_records из базы данных pyNotebook.db
# (везде далее доступ к этой таблице будет осуществляться через этот класс
# или его экземпляры (запросы к SQLAlchemy формируют экземпляры класса Notebook,
# читая поля date и record которых можно узнать содержимое базы данных),
# а создавая вручную объекты-экземпляры класса Notebook, например конструктором
# класса, можно заполнять их поля data, record,  и далее добавлять
# полученные объекты как записи в таблицу nb_records базы данных pyNotebook.db)
# ------------------------------------------------------
class Notebook(SqlAlchemy_Base):
    # имя таблицы (обязательный параметр)
    __tablename__ = 'nb_records'
    # поля таблицы nb_records
    date = sqlalchemy.Column(sqlalchemy.String, primary_key=True)
    record = sqlalchemy.Column(sqlalchemy.String)
    # конструктор
    def __init__(self, date, record):
        self.date = date
        self.record = record
# ------------------------------------------------------
# конец класса Notebook
# ------------------------------------------------------

# создаем метаинформацию по базе данных ("прогреваем" базу в памяти ЭВМ),
# и делаем ее готовой к дальнейшей быстрой работе.
SqlAlchemy_Base.metadata.create_all(SqlAlchemy_engine)
# ------------------------------------------------------
# конец инициализации SQLAlchemy-подсистемы
# ------------------------------------------------------

# ------------------------------------------------------
# подпрограмма-перехватчик вызовов (добавляет некую общую
# функциональность перед вызовами остальных перехватчиков)
# В данном проекте не особо нужна, оставлена как задел для
# последующих проектов или возможного улучшения текущего
# ------------------------------------------------------
@app.before_request
def before_request():
    # передаем в глобальную структуру Flask
    # текущего зарегистрированного модулем Flask-login пользователя
    g.user = current_user
# ------------------------------------------------------
# конец подпрограммы before_request
# ------------------------------------------------------

# ------------------------------------------------------
# дата, выбираемая пользователем будет храниться плохим "глобальным" способом,
# так как подпрограма-перехватчик постоянно перезапускается и ее забывает.
# по-хорошему это надо пофиксить и сделать через механизм session модуля flask
# ------------------------------------------------------
selected_date = datetime.now()
# строковое представление даты, понятное базе данных
# тоже костыльно-глобальное, но так проект хотя-бы работает
date_str = selected_date.strftime("%d.%m.%Y")
# ------------------------------------------------------

# ------------------------------------------------------
# подпрограмма-перехватчик обращения к страницам
# <base_dir>/ или <base_dir>/index
# содержит описания двух вспомогательных классов-форм ГПИ и
# перехватчики сообщений от кнопок этих форм
# ------------------------------------------------------

# ------------------------------------------------------
# класс формы ГПИ-выбора даты поиска записи в записной книжке
# к базовому классу Form добавлены
# 1) виджет selected_date класса DateField     - ГПИ выбора даты из календаря
# 2) кнопка btn_date_submit класса SubmitField - подтверждение выбранной даты
# ------------------------------------------------------
class DateForm(Form):
    selected_date = DateField('selected_date')
    btn_date_submit = SubmitField('btn_date_submit')
# ------------------------------------------------------
# конец класса DateForm
# ------------------------------------------------------

# ------------------------------------------------------
# класс формы ГПИ-вывода содержимого записной книжки
# к базовому классу Form добавлены
# 1) виджет notebook_record класса TextAreaField - многострочное текстовое окно
# 2) кнопка btn_submit класса SubmitField - приказ модификации записи в БД
# 3) кнопка btn_delete класса SubmitField - приказ удаления записи в БД
# ------------------------------------------------------
class ContentForm(Form):
    notebook_record = TextAreaField('notebook_record', validators=[Length(min=0, max=2000)])
    btn_submit = SubmitField('btn_submit')
    btn_delete = SubmitField('btn_delete')
# ------------------------------------------------------
# конец класса ContentForm
# ------------------------------------------------------

# перехватчик обращений к страницам /, /index
# запускается только если была авторизация flask-login
@app.route('/')
@app.route('/index', methods=['GET', 'POST'])
@login_required
def index():
    # -----------------------------------------------
    # декларируем использование глобальных переменных выбираемой даты
    # selected_date - в формате python
    # date_str - в человеко-читаемом формате "дд.мм.гггг"
    # -----------------------------------------------
    global selected_date
    global date_str
    
    # -----------------------------------------------
    # создаем объекты связи серверной части проекта
    # и виджетов ГПИ, отрисовываемых браузером
    # -----------------------------------------------
    # форма выбора даты
    form_date = DateForm()
    # форма отображения содержимого записной книжки
    # и кнопок "заменить" и "удалить"
    form_content = ContentForm()

    # -----------------------------------------------
    # если получено сообщение от кнопки btn_date_submit формы form_date (нажата)
    # -----------------------------------------------
    if form_date.btn_date_submit.data:
        # то взять дату из виджета DateField (не всегда передается корректно)
        selected_date = form_date.selected_date.data
        # и попытаться его преобразовать в человеко-читаемый вид
        tmp_date_str = date_str # запоминаем тиекущую выбранную дату
        try:
            # пытаемся выполнить преобразование в формат "дд.мм.гггг"
            date_str = selected_date.strftime("%d.%m.%Y")
        except:
            # если попытка не удалась, то восстанавливаем ранее выбранную дату
            date_str = tmp_date_str

    # -----------------------------------------------
    # если получено сообщение от кнопки btn_submit формы form_content (нажата)
    # -----------------------------------------------
    if form_content.btn_submit.data:
        # сохраняем модифицированную запись в промежуточной переменной
        new_notebook_record = form_content.notebook_record.data
        # пытаемся найти в базе данных запись (курсор на нее),
        # которая была выведена в текщее окно до модификации
        sql_answer = sql_session.query(Notebook).filter(Notebook.date == date_str).first()
        if sql_answer:
            # если запись нашлась, то исправляем ее
            sql_answer.record = new_notebook_record
            # посылаем flash-сообщение браузеру
            flash('Запись модифицирована')
        else:
            # если этой записи в БД не было, то это новая запись
            sql_session.add(Notebook(date_str, new_notebook_record))
            # посылаем flash-сообщение браузеру
            flash('Новая запись создана')
        # в любом случае фиксируем изменения в базе данных
        sql_session.commit()

    # -----------------------------------------------
    # если получено сообщение от кнопки btn_delete формы form_content (нажата)
    # -----------------------------------------------
    if form_content.btn_delete.data:
        # пытаемся найти в базе данных запись (курсор на нее),
        # которая была выведена в текщее окно на выбранную дату
        sql_answer = sql_session.query(Notebook).filter(Notebook.date == date_str).first()
        if sql_answer:
           # если запись нашлась, то удаляем ее
            sql_session.delete(sql_answer)
            # фиксируем изменение в базу данных
            sql_session.commit()
            # посылаем flash-сообщение браузеру
            flash('Запись удалена')
        else:
            # если записи в БД нет, то посылаем flash-сообщение браузеру
            flash('Не могу удалить несуществующую запись')

    # теперь еще раз перерисовываем (возможно модифицированную запись)
    sql_answer = sql_session.query(Notebook).filter(Notebook.date == date_str).first()
    # сначала проверяем, что запись в БД осталась (возможно была удалена)
    if sql_answer:
        # если запись осталась в базе данных, то выводим ее
        form_content.notebook_record.data = sql_answer.record
    else:
        # если записи нет в БД, то выводим сообщение, что ее в книжке нет
        form_content.notebook_record.data = f"на дату {date_str} записей в книжке нет"

    # команда jinja2 на отрисовку страницы index.html
    return render_template('index.html',
        title='pyFlaskNotebook - простая WEB-записная книжка',
        selected_date=date_str,
        form_date=form_date, form_content=form_content)
# ------------------------------------------------------
# конец подпрограммы index
# ------------------------------------------------------

# ------------------------------------------------------
# подпрограмма-перехватчик обращения к странице <base_dir>/login
# содержит описание вспомогательного класса-формы ГПИ и
# перехватчик сообщений от кнопок этой формы
# ------------------------------------------------------

# ------------------------------------------------------
# класс формы ГПИ-входа в систему
# к базовому классу Form добавлены
# 1) поле user_name класса TextField         - имя пользователя для входа
# 2) поле user_password класса PasswordField - пароль пользователя для входа
# 3) поле user_remember класса BooleanField  - флажок "запомнить в системе"
# ------------------------------------------------------
class LoginForm(Form):
    user_name = TextField('user_name', validators=[Required()])
    user_password = PasswordField('user_password', validators=[Required()])
    user_remember = BooleanField('user_remember', default=False)
# ------------------------------------------------------
# конец класса LoginForm
# ------------------------------------------------------

# перехватчик обращений к странице /login
@app.route('/login', methods=['GET', 'POST'])
def login():
    # создаем объект связи серверной части проекта
    # и виджетов ГПИ, отрисовываемых браузером
    form = LoginForm()
    
    # если получено сообщение от кнопки btn_submit формы form_content (нажата)
    if form.validate_on_submit():
        if (form.user_name.data == good_name) and (form.user_password.data == good_password):
            # поыслаем flash-сообщение браузеру
            flash('Доступ к записной книжке разрешен')
            # фиксируем введенное имя пользователя
            user.name = form.user_name.data
            # регистрируем пользователя в структурах flask-login
            login_user(user, remember=form.user_remember.data)
            # переход на главную страницу
            return redirect(url_for('index'))
        else:
            # поыслаем flash-сообщение браузеру
            flash('Неправильные имя пользователя или пароль')
    # команда jinja2 на отрисовку страницы login.html
    return render_template('login.html', title='Вход в систему', form=form)
# ------------------------------------------------------
# конец подпрограммы login
# ------------------------------------------------------

# ------------------------------------------------------
# подпрограмма-перехватчик обращения к странице <base_dir>/logout
# ------------------------------------------------------
@app.route('/logout')
def logout():
    # сообщение модулю flask-login о прекращении регистрации
    # пользователя в системе
    logout_user()
    # восстанавливаем имя пользователя на значение по-умолчанию
    user.name = good_name
    # поыслаем flash-сообщение браузеру о выходе из системы
    flash('Вы вышли из системы')
    # переход на главную страницу (с авто-переходом на страницу входа)
    return redirect(url_for('index'))
# ------------------------------------------------------
# конец подпрограммы logout
# ------------------------------------------------------

# ------------------------------------------------------
# Теперь все готово для запуска WEB-приложения
# ------------------------------------------------------
# вход в главный цикл flask-подсистемы
app.run(port=flask_port, debug=False)

# ------------------------------------------------------
# Конец файла pyFlaskNotebook.py
# ------------------------------------------------------
